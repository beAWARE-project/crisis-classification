from datetime import datetime
import pandas as pd

def parse_XML_dict(resp, colnames):

    # resp : dictionary generated by the gml file
    # colnames: parameters for request forecasting values

    dict_result = {}

    timestamp = resp['wfs:FeatureCollection']['@timeStamp']
    dict_result.update({'timestamp': timestamp})

    beginTime = resp['wfs:FeatureCollection']['wfs:member']['omso:GridSeriesObservation']['om:phenomenonTime']['gml:TimePeriod']['gml:beginPosition']
    dict_result.update({'beginTime': beginTime})

    endTime = resp['wfs:FeatureCollection']['wfs:member']['omso:GridSeriesObservation']['om:phenomenonTime']['gml:TimePeriod']['gml:endPosition']
    dict_result.update({'endTime': endTime})

    TimeMeas = resp['wfs:FeatureCollection']['wfs:member']['omso:GridSeriesObservation']['om:resultTime']['gml:TimeInstant']['gml:timePosition']
    dict_result.update({'TimeMeasurement': TimeMeas})

    http_params = resp['wfs:FeatureCollection']['wfs:member']['omso:GridSeriesObservation']['om:observedProperty']['@xlink:href']
    dict_result.update({'http_params': http_params})

    name = resp['wfs:FeatureCollection']['wfs:member']['omso:GridSeriesObservation']['om:featureOfInterest']['sams:SF_SpatialSamplingFeature']['sams:shape']['gml:MultiPoint']['gml:pointMembers']['gml:Point']['gml:name']
    dict_result.update({'name': name})

    pos = resp['wfs:FeatureCollection']['wfs:member']['omso:GridSeriesObservation']['om:featureOfInterest']['sams:SF_SpatialSamplingFeature']['sams:shape']['gml:MultiPoint']['gml:pointMembers']['gml:Point']['gml:pos']
    dict_result.update({'position': pos})

    # Data.frame of positions and phenomenonTime
    df_pos = resp['wfs:FeatureCollection']['wfs:member']['omso:GridSeriesObservation']['om:result']['gmlcov:MultiPointCoverage']['gml:domainSet']['gmlcov:SimpleMultiPoint']['gmlcov:positions']

    df_pos1 = df_pos.replace(" ", ",").strip("")
    df_pos1 = df_pos1.replace(",,,,,,,,,,,,,,,,", "")
    df_pos2 = df_pos1.splitlines()

    data_pos_phenTime = []
    for i in range(0,len(df_pos2)):
        p = df_pos2[i]
        p = p.split(",")
        if len(p) > 3 : p.remove('')

        pos_phenTime = []
        for j in range(0, len(p)):
            if type(p[j]) == str and j < (len(p)-1):
                pos_phenTime.append( float(p[j]) )
            else:
                pDT = datetime.utcfromtimestamp( int(p[2]) ).isoformat()
                pos_phenTime.append(pDT)

        # update the data frame with new entry
        data_pos_phenTime.append(pos_phenTime)

    # create a data frame with lat/long and phenomenonTime
    df_pos_phenTime = pd.DataFrame(data=data_pos_phenTime, columns=['Lat','Long','phenomenonTime'])


    # Forecasting values of each parameter
    df_res = resp['wfs:FeatureCollection']['wfs:member']['omso:GridSeriesObservation']['om:result']['gmlcov:MultiPointCoverage']['gml:rangeSet']['gml:DataBlock']['gml:doubleOrNilReasonTupleList']

    df = df_res.replace(" ", ",").strip("")
    df1 = df.replace(",,,,,,,,,,,,,,,,", "")
    df2 = df1.splitlines()

    data_vals = []
    for i in range( len(df2) ):
        t = df2[i].split(",")
        if len(t) > len(colnames) : t.remove('')

        t2 = []
        for j in range(0,len(t)):
            if type(t[j]) == str:
                t2.append( float(t[j]) )

        data_vals.append(t2)

    # Create a dataframe with forecasted values per parameter
    data = pd.DataFrame(data=data_vals, columns=colnames)

    # Concatenate the two data frames
    newdataset = pd.concat([df_pos_phenTime, data], axis=1)

    dict_result.update({'Data': newdataset})

    return dict_result
